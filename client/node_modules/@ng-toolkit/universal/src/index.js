"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const _utils_1 = require("@ng-toolkit/_utils");
const test_1 = require("@schematics/angular/utility/test");
const config_1 = require("@schematics/angular/utility/config");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const js_1 = require("@bugsnag/js");
const bugsnagClient = js_1.default('0b326fddc255310e516875c9874fed91');
function addUniversal(options) {
    if (!options.clientProject) {
        options.clientProject = options.project;
    }
    // Remove extra properties to avoid schema errors while running @nguniversal/express-engine schematic.
    const { disableBugsnag, http, directory, project } = options, optionsReduced = __rest(options, ["disableBugsnag", "http", "directory", "project"]);
    const expressOptions = optionsReduced;
    // Register bugsnag in order to catch and notify any rule error.
    bugsnagClient.config.beforeSend = (report) => {
        report.metaData = {
            subsystem: {
                package: 'universal',
                options: options
            }
        };
    };
    const templateSource = schematics_1.apply(schematics_1.url('./files'), [
        schematics_1.move(options.directory)
    ]);
    const rules = [];
    rules.push((tree) => {
        const packageJsonSource = JSON.parse(test_1.getFileContent(tree, `package.json`));
        if (packageJsonSource.dependencies['@ng-toolkit/serverless']) {
            tree.delete(`./local.js`);
            tree.delete(`./server.ts`);
            tree.delete(`./webpack.server.config.js`);
        }
        return tree;
    });
    rules.push(schematics_1.mergeWith(templateSource, schematics_1.MergeStrategy.Overwrite));
    rules.push(applyExpressEngine(options, expressOptions));
    rules.push(applyPackageJsonScripts(options));
    rules.push(enhanceServerModule(options));
    rules.push(renameAndEnhanceBrowserModule(options));
    rules.push(updateWebpackConfig());
    rules.push(addWrappers(options));
    rules.push(applyOtherNgToolkitSchematics(options));
    rules.push(addPrerender(options));
    if (!options.disableBugsnag) {
        return _utils_1.applyAndLog(schematics_1.chain(rules), bugsnagClient);
    }
    else {
        return schematics_1.chain(rules);
    }
}
exports.default = addUniversal;
function getSourceRoot(tree, options) {
    const workspace = config_1.getWorkspace(tree);
    return `/${workspace.projects[options.clientProject].sourceRoot}`;
}
function enhanceServerModule(options) {
    return (tree) => {
        const serverModulePath = `${getSourceRoot(tree, options)}/${options.appDir}/${options.rootModuleFileName}`;
        _utils_1.addImportStatement(tree, serverModulePath, 'ServerTransferStateModule', '@angular/platform-server');
        _utils_1.addToNgModule(tree, serverModulePath, 'imports', 'ServerTransferStateModule');
        return tree;
    };
}
function renameAndEnhanceBrowserModule(options) {
    return (tree) => {
        const browserModulePath = `${getSourceRoot(tree, options)}/${options.appDir}/${options.appDir}.browser.module.ts`;
        const modulePath = `${getSourceRoot(tree, options)}/${options.appDir}/${options.appDir}.module.ts`;
        const mainPath = `${getSourceRoot(tree, options)}/main.ts`;
        //create browser entry module
        _utils_1.createOrOverwriteFile(tree, browserModulePath, test_1.getFileContent(tree, modulePath).replace('AppModule', 'AppBrowserModule'));
        //change app.module.ts
        _utils_1.addImportStatement(tree, modulePath, 'CommonModule', '@angular/common');
        _utils_1.addToNgModule(tree, modulePath, 'imports', 'CommonModule');
        if (options.http) {
            _utils_1.addImportStatement(tree, modulePath, 'TransferHttpCacheModule', '@nguniversal/common');
            _utils_1.addImportStatement(tree, modulePath, 'HttpClientModule', '@angular/common/http');
            _utils_1.addToNgModule(tree, modulePath, 'imports', 'TransferHttpCacheModule');
            _utils_1.addToNgModule(tree, modulePath, 'imports', 'HttpClientModule');
        }
        //change app.browser.module.ts
        _utils_1.removeFromNgModule(tree, browserModulePath, 'imports', `BrowserModule.withServerTransition({ appId: '${options.appId}' })`);
        _utils_1.removeFromNgModule(tree, browserModulePath, 'declarations');
        _utils_1.addImportStatement(tree, browserModulePath, 'AppModule', './app.module');
        _utils_1.addToNgModule(tree, browserModulePath, 'imports', 'AppModule');
        _utils_1.addImportStatement(tree, browserModulePath, 'BrowserTransferStateModule', '@angular/platform-browser');
        _utils_1.addToNgModule(tree, browserModulePath, 'imports', 'BrowserTransferStateModule');
        //change entry in main.ts
        _utils_1.addImportStatement(tree, mainPath, 'AppBrowserModule', `./${options.appDir}/app.browser.module`);
        _utils_1.createOrOverwriteFile(tree, mainPath, test_1.getFileContent(tree, mainPath).replace('.bootstrapModule(AppModule)', '.bootstrapModule(AppBrowserModule)'));
        return tree;
    };
}
function updateWebpackConfig() {
    return (tree) => {
        const webpackConfig = test_1.getFileContent(tree, `./webpack.server.config.js`);
        _utils_1.createOrOverwriteFile(tree, `./webpack.server.config.js`, webpackConfig.replace('output: {', `output: {\n\tlibraryTarget: 'commonjs2',`));
        return tree;
    };
}
function addWrappers(options) {
    return (tree) => {
        const modulePath = `${getSourceRoot(tree, options)}/${options.appDir}/${options.appDir}.module.ts`;
        _utils_1.addImportStatement(tree, modulePath, 'NgtUniversalModule', '@ng-toolkit/universal');
        _utils_1.addToNgModule(tree, modulePath, 'imports', 'NgtUniversalModule');
        // search for 'window' occurences and replace them with injected Window instance
        tree.getDir(getSourceRoot(tree, options)).visit(visitor => {
            if (visitor.endsWith('.ts')) {
                let fileContent = test_1.getFileContent(tree, visitor);
                if (fileContent.match(/class.*{[\s\S]*?((?:[()'"`\s])localStorage)/)) {
                    _utils_1.addDependencyInjection(tree, visitor, 'localStorage', 'any', '@ng-toolkit/universal', 'LOCAL_STORAGE');
                    _utils_1.updateCode(tree, visitor, 'localStorage');
                    fileContent = test_1.getFileContent(tree, visitor);
                }
                if (fileContent.match(/class.*{[\s\S]*?((?:[()'"`\s])window)/)) {
                    _utils_1.addDependencyInjection(tree, visitor, 'window', 'Window', '@ng-toolkit/universal', 'WINDOW');
                    _utils_1.updateCode(tree, visitor, 'window');
                }
                // if (fileContent.match(/class.*{[\s\S]*?((?:[()'"`\s])document)/)) {
                //     addDependencyInjection(tree, visitor, 'document', 'Document', '@ng-toolkit/universal', 'NGT_DOCUMENT');
                //     updateCode(tree, visitor, 'document');
                // }
            }
        });
        return tree;
    };
}
function applyOtherNgToolkitSchematics(options) {
    return (tree) => {
        //applying other schematics (if installed)
        const ngToolkitSettings = _utils_1.getNgToolkitInfo(tree, options);
        ngToolkitSettings.universal = options;
        _utils_1.updateNgToolkitInfo(tree, ngToolkitSettings, options);
        let externals = [];
        if (ngToolkitSettings.serverless) {
            ngToolkitSettings.serverless.directory = options.directory;
            ngToolkitSettings.serverless.skipInstall = true;
            ngToolkitSettings.serverless.clientProject = options.clientProject;
            externals.push(schematics_1.externalSchematic('@ng-toolkit/serverless', 'ng-add', ngToolkitSettings.serverless));
        }
        else if (tree.exists(`${options.directory}/.firebaserc`)) {
            ngToolkitSettings.serverless = {};
            ngToolkitSettings.serverless.directory = options.directory;
            ngToolkitSettings.serverless.skipInstall = true;
            ngToolkitSettings.serverless.provider = 'firebase';
            ngToolkitSettings.serverless.clientProject = options.clientProject;
            externals.push(schematics_1.externalSchematic('@ng-toolkit/serverless', 'ng-add', ngToolkitSettings.serverless));
        }
        const workspace = config_1.getWorkspace(tree);
        const projectArchitect = workspace.projects[options.clientProject].architect;
        if (projectArchitect &&
            projectArchitect.build &&
            projectArchitect.build.configurations &&
            projectArchitect.build.configurations.production &&
            projectArchitect.build.configurations.production.serviceWorker != undefined) {
            if (!ngToolkitSettings.pwa) {
                ngToolkitSettings.pwa = {};
            }
            ngToolkitSettings.pwa.directory = options.directory;
            ngToolkitSettings.pwa.skipInstall = true;
            ngToolkitSettings.pwa.clientProject = options.clientProject;
            externals.push(schematics_1.externalSchematic('@ng-toolkit/pwa', 'ng-add', ngToolkitSettings.pwa));
        }
        if (externals.length > 0) {
            return schematics_1.chain(externals);
        }
        return tree;
    };
}
function applyExpressEngine(options, expressOptions) {
    return (tree) => {
        let hasUniversalBuild = false;
        const workspace = config_1.getWorkspace(tree);
        const architect = workspace.projects[options.clientProject].architect;
        if (architect) {
            for (let builder in architect) {
                if (architect[builder].builder === '@angular-devkit/build-angular:server') {
                    hasUniversalBuild = true;
                }
            }
        }
        if (!hasUniversalBuild) {
            return schematics_1.externalSchematic('@nguniversal/express-engine', 'ng-add', expressOptions);
        }
        else {
            return schematics_1.noop();
        }
    };
}
function applyPackageJsonScripts(options) {
    return (tree) => {
        const serverPort = options.serverPort ? options.serverPort.toString() : '4000';
        tree.overwrite(`local.js`, test_1.getFileContent(tree, `local.js`).replace(/__distFolder__/g, 'dist/server').replace(/__serverPort__/g, serverPort));
        tree.overwrite(`${options.serverFileName}`, test_1.getFileContent(tree, `${options.serverFileName}`).replace(/\/\/ Start up the Node server.*/gs, '').replace('const app = express();', 'export const app = express();'));
        const pkgPath = `/package.json`;
        const buffer = tree.read(pkgPath);
        if (buffer === null) {
            throw new schematics_1.SchematicsException('Could not find package.json');
        }
        const pkg = JSON.parse(buffer.toString());
        pkg.scripts['server'] = 'node local.js';
        pkg.scripts['build:prod'] = 'npm run build:ssr';
        pkg.scripts['serve:ssr'] = 'node local.js';
        tree.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
        _utils_1.addDependencyToPackageJson(tree, options, {
            type: dependencies_1.NodeDependencyType.Default,
            name: '@nguniversal/common',
            version: '8.1.0'
        });
        return tree;
    };
}
function addPrerender(options) {
    return (tree) => {
        // add dependencies
        _utils_1.addDependencyToPackageJson(tree, options, {
            type: dependencies_1.NodeDependencyType.Default,
            name: 'domino',
            version: '^2.1.3'
        });
        // add scripts
        const pkgPath = `package.json`;
        const buffer = tree.read(pkgPath);
        if (buffer === null) {
            throw new schematics_1.SchematicsException('Could not find package.json at addPrerender function');
        }
        const pkg = JSON.parse(buffer.toString());
        pkg.scripts['serve:prerender'] = 'node static.js';
        pkg.scripts['build:prerender'] = 'npm run build:prod && node dist/prerender.js';
        tree.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
        //add entry in webpack configuration
        const webpackConfig = test_1.getFileContent(tree, `./webpack.server.config.js`);
        _utils_1.createOrOverwriteFile(tree, `./webpack.server.config.js`, webpackConfig.replace(`server: './server.ts'`, `server: './server.ts',\n\tprerender: './prerender.ts'`));
        return tree;
    };
}
//# sourceMappingURL=index.js.map